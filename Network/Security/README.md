## 对称加密

## 原理

* A 和 B 同时持有一个相同的秘钥
* A 使用秘钥对明文进行加密，并将加密后的密文传输给 B
* B 使用同样的秘钥对密文进行解密就能获取到明文的内容
* 即使第三方获取到了解密算法，因为没有秘钥也是无法将密文解析成原来的明文的

## 实现

### RC4 对称加密序列算法

明文可以和密钥序列通过异或操作得到密文。

```
1 0 1 0 密钥序列
  异或
0 1 1 0 明文
  等于
1 1 0 0 密文
```

同样密文可以通过密钥序列通过异或操作得到明文

```
1 0 1 0 密钥序列
  异或
1 1 0 0 密文
  等于
0 1 1 0 明文
```

## 非对称加密

### 原理

* 首先通过算法生成一对密钥分别称为 **公钥**（可以公开的） 和 **私钥**
* 同样一份明文如果使用 **公钥** 加密了，则只能使用对用的 **私钥** 才能解密
* 反过来如果明文使用 **私钥** 加密了，则是能使用 **公钥** 才能解密

#### 场景1

GitHub

* A 通过算法生成一对密钥，自己保留私钥，并把公钥提供给 B 或其他人
* B 或者其他人通过公钥将明文进行加密并传输给 A
* A 通过私钥将密文进行解密

#### 场景2

身份验证，签名

* A 通过算法生成一对密钥，自己保留私钥，并把公钥提供给 B 或其他人
* A 通过私钥加密了一段数据，并将数据发送给 B 或者其他人
* B 或者其他人通过手上 A 的公钥能够将这段数据解密
* 则可以表示这是 A 所发送的数据

## https 验证流程

dv --> cv --> ev

![](https://user-gold-cdn.xitu.io/2020/3/14/170d977c7fed5029?w=599&h=378&f=png&s=86647)

* 证书订阅人向登记机构申请证书
* 登记机构通过 CA 生成一对密钥，CA 保留私钥
* 登记机构将公钥颁发给证书订阅者
* 证书订阅者将公钥部署至服务器
* 浏览器向服务器请求时，服务器会将公钥发送给浏览器
* 浏览器通过服务器给到的公钥去 CA 验证合法性